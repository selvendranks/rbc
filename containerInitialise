@tool
extends Node3D

@export var container_scene: PackedScene
@export var multimesh_mesh_mid: Mesh
@export var multimesh_mesh_far: Mesh

@export var min_marker: NodePath
@export var max_marker: NodePath

@export var containers_x: int = 3
@export var containers_z: int = 3
@export var containers_y_min: int = 2
@export var containers_y_max: int = 4

@export var container_height: float = 2.0
@export var y_spacing: float = 0.0

@export var reference_path: NodePath
@export var distance_threshold_mid: float = 20.0
@export var distance_threshold_far: float = 60.0

@export var random_seed: int = 12345
@export var regenerate_now: bool = false

var rng := RandomNumberGenerator.new()
var scene_root: Node3D
var multimesh_mid: MultiMeshInstance3D
var multimesh_far: MultiMeshInstance3D
var viz_box: MeshInstance3D
var container_states: Dictionary = {}   # uuid -> { "transform": Transform3D, "is_scene": bool }

# --- Lifecycle ---
func _ready():
	_ensure_holders()
	_clear_scene_root()
	container_states.clear()
	_spawn_initial_grid()
	set_process(true)

func _process(_delta: float) -> void:
	if regenerate_now:
		regenerate_now = false
		_clear_scene_root()
		container_states.clear()
		_spawn_initial_grid()
	_update_containers()
	_update_visual_box()

# --- Setup ---
func _ensure_holders():
	if scene_root == null:
		scene_root = Node3D.new()
		scene_root.name = "SceneContainers"
		add_child(scene_root)

	if multimesh_mid == null:
		multimesh_mid = MultiMeshInstance3D.new()
		multimesh_mid.name = "MidMultiMesh"
		add_child(multimesh_mid)
		multimesh_mid.multimesh = MultiMesh.new()
		multimesh_mid.multimesh.transform_format = MultiMesh.TRANSFORM_3D

	if multimesh_far == null:
		multimesh_far = MultiMeshInstance3D.new()
		multimesh_far.name = "FarMultiMesh"
		add_child(multimesh_far)
		multimesh_far.multimesh = MultiMesh.new()
		multimesh_far.multimesh.transform_format = MultiMesh.TRANSFORM_3D

	if viz_box == null:
		viz_box = MeshInstance3D.new()
		viz_box.name = "BoundsViz"
		viz_box.mesh = BoxMesh.new()
		add_child(viz_box)

# --- Helpers ---
func _get_reference() -> Node3D:
	if reference_path.is_empty():
		return null
	return get_node_or_null(reference_path) as Node3D

func _get_bounds() -> Array:
	var min_node = get_node_or_null(min_marker) as Node3D
	var max_node = get_node_or_null(max_marker) as Node3D
	if min_node and max_node:
		return [min_node.global_transform.origin, max_node.global_transform.origin]
	return [Vector3.ZERO, Vector3.ONE]

# --- Grid spawn ---
func _spawn_initial_grid():
	rng.seed = random_seed
	var bounds = _get_bounds()
	var min_bounds: Vector3 = bounds[0]
	var max_bounds: Vector3 = bounds[1]

	var size := max_bounds - min_bounds
	var step_x := (size.x / float(containers_x - 1)) if containers_x > 1 else 0.0
	var step_z := (size.z / float(containers_z - 1)) if containers_z > 1 else 0.0
	var step_y := container_height + y_spacing

	for x in range(containers_x):
		for z in range(containers_z):
			var y_count := rng.randi_range(containers_y_min, containers_y_max)
			for y in range(y_count):
				var uuid := new_uuid()
				var pos = Vector3(
					min_bounds.x + x * step_x,
					min_bounds.y + y * step_y,
					min_bounds.z + z * step_z
				)
				container_states[uuid] = {
					"transform": Transform3D(Basis(), pos),
					"is_scene": false
				}

# --- Update ---
func _update_containers():
	var ref := _get_reference()
	var ref_pos := Vector3.ZERO
	if ref:
		ref_pos = ref.global_transform.origin

	var mid_transforms: Array[Transform3D] = []
	var far_transforms: Array[Transform3D] = []

	for uuid in container_states.keys():
		var state = container_states[uuid]
		var xf: Transform3D = state["transform"]
		var is_scene: bool = state["is_scene"]

		var dist = xf.origin.distance_to(ref_pos)

		if dist < distance_threshold_mid:
			if not is_scene:
				var inst := container_scene.instantiate() as Node3D
				inst.name = "Container_%s" % uuid
				inst.global_transform = xf
				scene_root.add_child(inst)
				state["is_scene"] = true
				container_states[uuid] = state
			else:
				var inst = scene_root.get_node_or_null("Container_%s" % uuid)
				if inst:
					state["transform"] = inst.global_transform
					container_states[uuid] = state

		elif dist < distance_threshold_far:
			if is_scene:
				var inst = scene_root.get_node_or_null("Container_%s" % uuid)
				if inst:
					state["transform"] = inst.global_transform
					inst.queue_free()
				state["is_scene"] = false
				container_states[uuid] = state
			mid_transforms.append(state["transform"])

		else:
			if is_scene:
				var inst = scene_root.get_node_or_null("Container_%s" % uuid)
				if inst:
					state["transform"] = inst.global_transform
					inst.queue_free()
				state["is_scene"] = false
				container_states[uuid] = state
			far_transforms.append(state["transform"])

	_apply_multimesh(multimesh_mid, multimesh_mesh_mid, mid_transforms, Color(0.6,0.8,1.0))
	_apply_multimesh(multimesh_far, multimesh_mesh_far, far_transforms, Color(0.4,0.6,0.9))

func _apply_multimesh(mmi: MultiMeshInstance3D, mesh: Mesh, transforms: Array[Transform3D], fallback_color: Color):
	if mesh == null:
		var cube := BoxMesh.new()
		cube.size = Vector3.ONE
		var mat := StandardMaterial3D.new()
		mat.albedo_color = fallback_color
		cube.material = mat
		mesh = cube

	var mm := mmi.multimesh
	mm.mesh = mesh
	mm.instance_count = transforms.size()
	for i in range(transforms.size()):
		mm.set_instance_transform(i, transforms[i])
	mmi.visible = transforms.size() > 0

func _clear_scene_root():
	for child in scene_root.get_children():
		child.queue_free()

# --- Visualization ---
func _update_visual_box():
	if not viz_box:
		return

	var bounds = _get_bounds()
	var min_bounds: Vector3 = bounds[0]
	var max_bounds: Vector3 = bounds[1]

	var size = Vector3(max_bounds.x - min_bounds.x, 0.0, max_bounds.z - min_bounds.z)
	var center = Vector3((min_bounds.x + max_bounds.x) * 0.5, min_bounds.y, (min_bounds.z + max_bounds.z) * 0.5)

	# Define square corners in local space
	var corners = [
		Vector3(-0.5, 0, -0.5),
		Vector3( 0.5, 0, -0.5),
		Vector3( 0.5, 0,  0.5),
		Vector3(-0.5, 0,  0.5),
		Vector3(-0.5, 0, -0.5) # repeat first to close
	]

	# Build line mesh with SurfaceTool
	var st := SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_LINE_STRIP)

	for c in corners:
		st.add_vertex(c)

	var mesh := st.commit()

	viz_box.mesh = mesh
	viz_box.scale = Vector3(size.x, 1.0, size.z)
	viz_box.global_transform.origin = center
	viz_box.visible = Engine.is_editor_hint()
	
# --- UUID helper ---
func new_uuid() -> String:
	var bytes: PackedByteArray = Crypto.new().generate_random_bytes(16)
	var hex := bytes.hex_encode()
	return "%s-%s-%s-%s-%s" % [
		hex.substr(0, 8),
		hex.substr(8, 4),
		hex.substr(12, 4),
		hex.substr(16, 4),
		hex.substr(20, 12)
	]
